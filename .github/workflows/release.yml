name: Release

on:
  workflow_dispatch:
    inputs:
      release_notes:
        description: 'Release notes (optional)'
        required: false
        type: string
        default: ''

jobs:
  # Extract version from Cargo.toml
  extract-version:
    runs-on: ubuntu-latest
    permissions:
      contents: read
    outputs:
      version: ${{ steps.get-version.outputs.version }}
    steps:
      - uses: actions/checkout@v4
      
      - name: Extract version from Cargo.toml
        id: get-version
        run: |
          VERSION=$(grep '^version = ' Cargo.toml | head -1 | sed 's/version = "\(.*\)"/\1/')
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Extracted version: $VERSION"

  # Run tests before building
  test:
    runs-on: ubuntu-latest
    permissions:
      contents: read
    steps:
      - uses: actions/checkout@v4
      
      - name: Install Rust
        uses: dtolnay/rust-toolchain@stable
      
      - name: Run tests
        run: cargo test

  # Build matrix for all platforms
  build:
    needs: [extract-version, test]
    permissions:
      contents: read
    environment: ${{ contains(fromJSON('["x86_64-apple-darwin", "aarch64-apple-darwin"]'), matrix.target) && 'release' || '' }}
    strategy:
      fail-fast: false
      matrix:
        include:
          # Windows builds (native)
          - target: x86_64-pc-windows-msvc
            os: windows-latest
            use_cross: false
          - target: i686-pc-windows-msvc
            os: windows-latest
            use_cross: false
          # Windows ARM64 (native with target)
          - target: aarch64-pc-windows-msvc
            os: windows-latest
            use_cross: false
          
          # macOS builds (native)
          - target: x86_64-apple-darwin
            os: macos-latest
            use_cross: false
          - target: aarch64-apple-darwin
            os: macos-latest
            use_cross: false
          
          # Linux builds
          - target: x86_64-unknown-linux-gnu
            os: ubuntu-latest
            use_cross: false
          - target: i686-unknown-linux-gnu
            os: ubuntu-latest
            use_cross: true
          - target: aarch64-unknown-linux-gnu
            os: ubuntu-latest
            use_cross: true

    runs-on: ${{ matrix.os }}
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Install Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.target }}
      
      - name: Install cargo-bundle
        if: ${{ !matrix.use_cross && runner.os == 'macOS' }}
        run: cargo install cargo-bundle
      
      - name: Cache cross installation
        if: matrix.use_cross
        id: cache-cross
        uses: actions/cache@v4
        with:
          path: ~/.cargo/bin/cross
          key: ${{ runner.os }}-cross-${{ hashFiles('Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-cross-
      
      - name: Install cross (if needed)
        if: matrix.use_cross && steps.cache-cross.outputs.cache-hit != 'true'
        run: cargo install cross --git https://github.com/cross-rs/cross --force
      
      - name: Build (native)
        if: ${{ !matrix.use_cross }}
        run: |
          if [ "$RUNNER_OS" == "Windows" ]; then
            cargo build --release --target ${{ matrix.target }}
          elif [ "$RUNNER_OS" == "macOS" ]; then
            ./build.sh
          else
            cargo build --release --target ${{ matrix.target }}
          fi
        shell: bash
      
      - name: Build (cross)
        if: matrix.use_cross
        run: cross build --release --target ${{ matrix.target }}
      
      - name: Import code signing certificate (macOS)
        if: runner.os == 'macOS'
        env:
          BUILD_CERTIFICATE_BASE64: ${{ secrets.BUILD_CERTIFICATE_BASE64 }}
          P12_PASSWORD: ${{ secrets.P12_PASSWORD }}
          KEYCHAIN_PASSWORD: ${{ secrets.P12_PASSWORD }}
        run: |
          # Create variables
          CERTIFICATE_PATH=$RUNNER_TEMP/build_certificate.p12
          KEYCHAIN_PATH=$RUNNER_TEMP/app-signing.keychain-db
          
          # Import certificate from secrets
          echo -n "$BUILD_CERTIFICATE_BASE64" | base64 --decode -o $CERTIFICATE_PATH
          
          # Create temporary keychain
          security create-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH
          security set-keychain-settings -lut 21600 $KEYCHAIN_PATH
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH
          
          # Import certificate to keychain
          security import $CERTIFICATE_PATH -P "$P12_PASSWORD" -A -t cert -f pkcs12 -k $KEYCHAIN_PATH
          security list-keychain -d user -s $KEYCHAIN_PATH
          
          # Allow codesign to access the keychain
          security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH
      
      - name: Sign macOS app bundle
        if: runner.os == 'macOS'
        run: |
          APP_BUNDLE="target/release/bundle/osx/PingMonitor.app"
          if [ -d "$APP_BUNDLE" ]; then
            echo "Signing $APP_BUNDLE..."
            
            # Find the certificate identity - prefer Developer ID Application
            IDENTITY=$(security find-identity -v -p codesigning | awk '/Developer ID Application/ {match($0, /"[^"]*"/); print substr($0, RSTART+1, RLENGTH-2); exit}')
            
            if [ -z "$IDENTITY" ]; then
              echo "Error: No Developer ID Application certificate found"
              echo "Available identities:"
              security find-identity -v -p codesigning
              exit 1
            fi
            
            echo "Using identity: $IDENTITY"
            
            # Sign the app bundle with hardened runtime (without --deep flag)
            codesign --force --sign "$IDENTITY" --options runtime --timestamp "$APP_BUNDLE"
            
            # Verify the signature
            codesign --verify --verbose=2 "$APP_BUNDLE"
            
            echo "✓ App bundle signed successfully"
          else
            echo "Warning: App bundle not found at $APP_BUNDLE"
          fi
      
      - name: Prepare artifact (Windows)
        if: runner.os == 'Windows'
        run: |
          $VERSION = "${{ needs.extract-version.outputs.version }}"
          $TARGET = "${{ matrix.target }}"
          $ARTIFACT_NAME = "ping-monitor-$VERSION-$TARGET"
          
          New-Item -ItemType Directory -Force -Path "artifacts"
          
          # Package the plain executable
          $BINARY_PATH = "target\$TARGET\release\ping-monitor.exe"
          if (Test-Path $BINARY_PATH) {
            Write-Host "Packaging executable at $BINARY_PATH"
            Copy-Item $BINARY_PATH "artifacts\ping-monitor.exe"
            Compress-Archive -Path "artifacts\ping-monitor.exe" -DestinationPath "$ARTIFACT_NAME.zip"
          } else {
            Write-Host "Error: Binary not found at $BINARY_PATH"
            exit 1
          }
          
          Add-Content -Path $env:GITHUB_ENV -Value "ARTIFACT_NAME=$ARTIFACT_NAME"
        shell: pwsh
      
      - name: Prepare artifact (Unix)
        if: runner.os != 'Windows'
        run: |
          VERSION="${{ needs.extract-version.outputs.version }}"
          TARGET="${{ matrix.target }}"
          ARTIFACT_NAME="ping-monitor-${VERSION}-${TARGET}"
          
          mkdir -p artifacts
          
          # Check if macOS app bundle was created
          if [ "$RUNNER_OS" == "macOS" ]; then
            APP_BUNDLE="target/release/bundle/osx/PingMonitor.app"
            if [ -d "$APP_BUNDLE" ]; then
              echo "Found macOS app bundle at $APP_BUNDLE"
              
              # Ensure the executable has proper permissions
              EXECUTABLE="$APP_BUNDLE/Contents/MacOS/ping-monitor"
              if [ -f "$EXECUTABLE" ]; then
                echo "Setting executable permissions on $EXECUTABLE"
                chmod +x "$EXECUTABLE"
                
                # Verify the executable has correct permissions
                if [ -x "$EXECUTABLE" ]; then
                  echo "✓ Executable permissions verified: $EXECUTABLE"
                  ls -l "$EXECUTABLE"
                  
                  # Verify it's a valid Mach-O executable
                  echo "Verifying binary format..."
                  file "$EXECUTABLE"
                  if file "$EXECUTABLE" | grep -q "Mach-O"; then
                    echo "✓ Valid Mach-O executable confirmed"
                  else
                    echo "✗ ERROR: Not a valid Mach-O executable!"
                    exit 1
                  fi
                else
                  echo "✗ ERROR: Executable is not executable after chmod!"
                  ls -l "$EXECUTABLE"
                  exit 1
                fi
              else
                echo "✗ ERROR: Executable not found at $EXECUTABLE"
                exit 1
              fi
              
              # Create a zip of the .app bundle preserving permissions
              WORKSPACE_DIR="$(pwd)"
              (cd "$WORKSPACE_DIR/target/release/bundle/osx" && zip -ry "$WORKSPACE_DIR/${ARTIFACT_NAME}.zip" PingMonitor.app)
              
              # Verify permissions are preserved in the zip
              echo "Verifying executable in zip archive..."
              if unzip -l "${ARTIFACT_NAME}.zip" | grep -q "PingMonitor.app/Contents/MacOS/ping-monitor"; then
                echo "✓ Executable found in zip archive"
              else
                echo "✗ ERROR: Executable not found in zip archive!"
                unzip -l "${ARTIFACT_NAME}.zip" | head -20
                exit 1
              fi
              
              echo "ARTIFACT_NAME=${ARTIFACT_NAME}" >> $GITHUB_ENV
              exit 0
            else
              echo "App bundle not found, using plain executable"
            fi
          fi
          
          # Fallback to plain binary
          BINARY_PATH="target/${TARGET}/release/ping-monitor"
          cp "$BINARY_PATH" "artifacts/ping-monitor"
          chmod +x "artifacts/ping-monitor"
          
          # Create ZIP archive preserving permissions
          cd artifacts
          zip -ry "../${ARTIFACT_NAME}.zip" ping-monitor
          cd ..
          
          echo "ARTIFACT_NAME=${ARTIFACT_NAME}" >> $GITHUB_ENV
        shell: bash
      
      - name: Cleanup code signing (macOS)
        if: always() && runner.os == 'macOS'
        run: |
          # Clean up the temporary keychain
          KEYCHAIN_PATH=$RUNNER_TEMP/app-signing.keychain-db
          if [ -f "$KEYCHAIN_PATH" ]; then
            security delete-keychain $KEYCHAIN_PATH || true
          fi
          
          # Clean up the certificate file
          CERTIFICATE_PATH=$RUNNER_TEMP/build_certificate.p12
          if [ -f "$CERTIFICATE_PATH" ]; then
            rm -f $CERTIFICATE_PATH
          fi
      
      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.ARTIFACT_NAME }}
          path: ${{ env.ARTIFACT_NAME }}.zip
          retention-days: 1

  # Create GitHub release
  release:
    needs: [extract-version, build]
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - uses: actions/checkout@v4
      
      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts
      
      - name: Prepare release files
        run: |
          mkdir -p release-files
          find artifacts -name "*.zip" -exec cp {} release-files/ \;
          ls -lh release-files/
      
      - name: Create release notes
        id: release-notes
        run: |
          VERSION="${{ needs.extract-version.outputs.version }}"
          NOTES="${{ github.event.inputs.release_notes }}"
          
          if [ -z "$NOTES" ]; then
            NOTES="Release version ${VERSION}"
          fi
          
          echo "notes<<EOF" >> $GITHUB_OUTPUT
          echo "$NOTES" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
      
      - name: Create Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: v${{ needs.extract-version.outputs.version }}
          name: Release v${{ needs.extract-version.outputs.version }}
          body: ${{ steps.release-notes.outputs.notes }}
          files: release-files/*.zip
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
